# 1.3 Memory Fundamentals

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus

## Physical Hardware Overview

The NES CPU has a 16-bit address bus, providing 64 KB ($0000–$FFFF) of addressable space. This space is divided into:

* **Internal RAM: 2 KB of work RAM, mirrored four times
* **PPU Registers: Memory-mapped I/O for PPU communication, mirrored
* **APU/I/O Registers: Audio and controller I/O, not mirrored
* **Cartridge Space: PRG ROM, CHR ROM, mapper registers, optional RAM

The PPU has its own 14-bit address bus (16 KB), separate from the CPU bus.

## NES Terminology Definitions

* **CPU Memory Map: The 64 KB address space visible to the CPU
* **PPU Memory Map: The 16 KB address space visible to the PPU
* **Zero Page: First 256 bytes ($0000–$00FF), fastest addressing mode
* **Stack: Fixed 256-byte region at $0100–$01FF, grows downward
* **Mirroring: Multiple addresses map to the same physical memory
* **Memory-Mapped I/O: Hardware registers accessible as memory addresses
* **PRG ROM: Program ROM, contains CPU code and data
* **CHR ROM: Character ROM, contains PPU pattern data (tiles)
* **Mapper: Cartridge hardware that remaps ROM banks

## Core Rules and Invariants

### CPU Memory Map ($0000–$FFFF)

| Address Range | Size | Description | Access | Notes |
|--------------|------|-------------|--------|-------|
| $0000–$00FF | 256 B | Zero Page | R/W | Fastest addressing (3 cycles) |
| $0100–$01FF | 256 B | Stack | R/W | Fixed location, grows downward |
| $0200–$02FF | 256 B | OAM Buffer | R/W | Sprite data (transferred via DMA) |
| $0300–$07FF | 1.25 KB | Work RAM | R/W | General-purpose RAM |
| $0800–$1FFF | 6 KB | RAM Mirrors | R/W | Mirrors of $0000–$07FF |
| $0–$7 | 8 B | PPU Registers | R/W | Mirrored every 8 bytes |
| $2008–$3FFF | 8 KB | PPU Register Mirrors | R/W | Mirrors of $0–$7 |
| $0–$3 | 20 B | APU Registers | W | Audio channels |
| $4 | 1 B | OAM DMA | W | Sprite DMA transfer |
| $5 | 1 B | APU Status | R/W | Channel enable/status |
| $6 | 1 B | Controller 1 | R/W | Strobe (W), Data (R) |
| $7 | 1 B | Controller 2 / Frame Counter | R/W | Strobe (W), Data (R), Frame counter (W) |
| $4018–$401F | 8 B | APU/IO Test | R/W | Test registers (unused) |
| $4020–$5FFF | 8 KB | Cartridge Expansion | R/W | Mapper-specific |
| $6000–$7FFF | 8 KB | Cartridge RAM | R/W | Optional SRAM (battery-backed) |
| $8000–$FFFF | 32 KB | Cartridge PRG ROM | R | Program ROM (mapper-dependent) |

### Memory Mirroring Details

**RAM Mirroring ($0000–$1FFF):**
- Physical RAM: $0000–$07FF (2 KB)
- Mirrors: $0800–$0FFF, $1000–$17FF, $1800–$1FFF
- **All mirrors access same physical RAM**
- Example: Writing to $0000 and $0800 writes to same location

**PPU Register Mirroring ($0–$3FFF):**
- Base registers: $0–$7 (8 bytes)
- Mirrors: $2008–$200F, $2010–$2017, ... $3FF8–$3FFF
- **All mirrors access same registers**
- Example: Reading $2 and $3FFA reads same register

**Best practice**: Use base addresses ($0–$7) for clarity, but mirrors work identically.

### Zero Page Philosophy

* Zero page ($0000–$00FF) uses 1-byte addresses (faster, fewer cycles)
* Critical variables should live in zero page
* Zero page is precious real estate; allocate carefully
* Zero page indexed addressing wraps at page boundary ($00FF + 1 = $0000)

### Stack Location and Constraints

* Stack is **fixed** at $0100–$01FF (cannot be relocated)
* Stack pointer (SP) is 8-bit, wraps automatically
* Stack grows **downward** (SP decrements on push)
* Initial SP should be set to $FF (points to $01FF)
* Stack overflow/underflow wraps silently (no hardware protection)

### ROM vs RAM vs Memory-Mapped I/O

* **ROM: Read-only, contains code/data from cartridge
* **RAM: Read-write, volatile (lost on power-off)
* **SRAM: Battery-backed RAM in cartridge ($6000–$7FFF)
* **Memory-Mapped I/O: Registers that control hardware, not storage

### PPU Memory Map ($0000–$3FFF)

| Address Range | Size | Description | Access | Notes |
|--------------|------|-------------|--------|-------|
| $0000–$0FFF | 4 KB | Pattern Table 0 | R/W* | CHR ROM (R) or CHR RAM (R/W) |
| $1000–$1FFF | 4 KB | Pattern Table 1 | R/W* | CHR ROM (R) or CHR RAM (R/W) |
| $0–$23FF | 1 KB | Name Table 0 | R/W | Background tile map |
| $23C0–$23FF | 64 B | Attribute Table 0 | R/W | Palette selection (2×2 tiles) |
| $2400–$27FF | 1 KB | Name Table 1 | R/W | Background tile map |
| $27C0–$27FF | 64 B | Attribute Table 1 | R/W | Palette selection |
| $2800–$2BFF | 1 KB | Name Table 2 | R/W | Background tile map |
| $2BC0–$2BFF | 64 B | Attribute Table 2 | R/W | Palette selection |
| $2C00–$2FFF | 1 KB | Name Table 3 | R/W | Background tile map |
| $2FC0–$2FFF | 64 B | Attribute Table 3 | R/W | Palette selection |
| $3000–$3EFF | 3.75 KB | Mirrors | R/W | Mirrors of $0–$2EFF |
| $3F00 | 1 B | Universal BG Color | R/W | Shared by all palettes |
| $3F01–$3F03 | 3 B | Background Palette 0 | R/W | 4 colors (1 universal + 3) |
| $3F05–$3F07 | 3 B | Background Palette 1 | R/W | 4 colors |
| $3F09–$3F0B | 3 B | Background Palette 2 | R/W | 4 colors |
| $3F0D–$3F0F | 3 B | Background Palette 3 | R/W | 4 colors |
| $3F11–$3F13 | 3 B | Sprite Palette 0 | R/W | 4 colors |
| $3F15–$3F17 | 3 B | Sprite Palette 1 | R/W | 4 colors |
| $3F19–$3F1B | 3 B | Sprite Palette 2 | R/W | 4 colors |
| $3F1D–$3F1F | 3 B | Sprite Palette 3 | R/W | 4 colors |
| $3F20–$3FFF | 224 B | Palette Mirrors | R/W | Mirrors of $3F00–$3F1F |

**Note**: *CHR ROM is read-only, CHR RAM is read-write (cartridge-dependent)

### Name Table Mirroring

The NES has 2 KB of physical VRAM, but 4 name tables (4 KB). **Mirroring** determines how name tables map to physical VRAM:

| Mirroring Type | Physical VRAM | Name Table Mapping | Use Case |
|---------------|---------------|-------------------|----------|
| Horizontal | $0–$27FF | $0=$2400, $2800=$2C00 | Vertical scrolling games |
| Vertical | $0–$2BFF | $0=$2800, $2400=$2C00 | Horizontal scrolling games |
| 4-screen | $0–$2FFF | All 4 name tables unique | Complex games (requires extra RAM) |
| Single-screen | $0–$23FF | All 4 name tables = $0 | Simple games |

**Mirroring is controlled by cartridge hardware** (mapper or hardwired), not software.

### Memory Access Restrictions

| Memory Type | Read During Rendering | Write During Rendering | Safe Period |
|-------------|----------------------|----------------------|-------------|
| Pattern Tables (CHR ROM) | ✅ Yes | ❌ No (ROM) | Always (read-only) |
| Pattern Tables (CHR RAM) | ❌ No | ❌ No | VBlank only |
| Name Tables | ❌ No | ❌ No | VBlank only |
| Attribute Tables | ❌ No | ❌ No | VBlank only |
| Palette RAM | ⚠️ Risky | ❌ No | VBlank only (mid-frame changes possible but risky) |
| OAM | ❌ No | ❌ No | VBlank only (use DMA) |

**Best practice**: All VRAM writes during VBlank only. Pattern table reads (CHR ROM) are always safe.

## Minimal Correct Usage Example

```asm
; Zero page allocation
zp_temp = $00       ; Temporary variable
zp_ptr = $02        ; 16-bit pointer (low, high)

; Using zero page
LDA #$42
STA zp_temp         ; Store to zero page (faster)

; 16-bit pointer in zero page
LDA #<data_table    ; Low byte
STA zp_ptr
LDA #>data_table    ; High byte
STA zp_ptr+1

; Indirect addressing through zero page pointer
LDY #0
LDA (zp_ptr),Y      ; Load from address in zp_ptr

; Stack usage
PHA                 ; Push A
TXA
PHA                 ; Push X
; ... use A and X ...
PLA                 ; Pull X
TAX
PLA                 ; Pull A

; Accessing PPU registers
LDA $2           ; Read PPU status (clears VBlank flag)
LDA #$20
STA $6           ; PPU address high
LDA #$00
STA $6           ; PPU address low
LDA $7           ; Read from PPU data

data_table:
    .byte $01, $02, $03
```

## Gold Standard Example

```asm
; Complete memory usage example following best practices
reset:
    ; Initialize zero page variables (fastest access)
    LDA #0
    STA frame_counter    ; $04 - frame counter
    STA frame_ready      ; $05 - frame synchronization
    STA scroll_x         ; $06 - horizontal scroll
    STA scroll_y         ; $07 - vertical scroll
    
    ; Set up zero page pointer
    LDA #<data_table
    STA zp_ptr           ; $02 - pointer low byte
    LDA #>data_table
    STA zp_ptr+1         ; $03 - pointer high byte
    
    ; Access data via pointer (indirect indexed)
    LDY #0
    LDA (zp_ptr),Y       ; Load first byte from data_table
    
    ; Stack operations (preserve registers)
    PHA                  ; Save accumulator
    TXA
    PHA                  ; Save X register
    TYA
    PHA                  ; Save Y register
    
    ; Use registers for temporary operations
    LDA #$42
    TAX                  ; Transfer to X
    TXA                  ; Transfer back to A
    
    ; Restore registers
    PLA                  ; Restore Y
    TAY
    PLA                  ; Restore X
    TAX
    PLA                  ; Restore A
    
    ; Access PPU registers (memory-mapped I/O)
    LDA $2            ; Read PPU status (clears VBlank flag)
    LDA #$3F
    STA $6            ; PPU address high
    LDA #$00
    STA $6            ; PPU address low
    LDA $7            ; Read from PPU data
    
    ; Access APU registers
    LDA #$00
    STA $0            ; Pulse 1 control
    STA $1            ; Pulse 1 sweep
    STA $2            ; Pulse 1 timer low
    STA $3            ; Pulse 1 timer high
    
    ; Access controller
    LDA #$01
    STA $6            ; Strobe controller
    LDA #$00
    STA $6            ; Clear strobe
    LDA $6            ; Read button A
    
    ; RAM usage (game state)
    LDA #1
    STA game_state       ; $0300 - game state
    LDA #3
    STA lives           ; $0302 - player lives
    
    ; OAM buffer access
    LDX #0
    LDA #$FF
clear_oam:
    STA $0200,X          ; OAM buffer at $0200-$02FF
    INX
    BNE clear_oam
    
    RTS

; Data in ROM
data_table:
    .byte $01, $02, $03, $04
```

## Validation Rules

### Memory Access Rules

1. **Zero Page Priority: Frequently accessed variables must be in zero page
2. **Stack Usage: Stack is fixed at $0100-$01FF, cannot be relocated
3. **Register Preservation: Save/restore registers in subroutines
4. **Pointer Setup: Zero page pointers must be initialized before use
5. **PPU Register Access: Must read $2 before VRAM operations
6. **RAM Clearing: All RAM must be cleared to known state on reset
7. **OAM Buffer: OAM buffer at $0200-$02FF, must be updated via DMA

### Addressing Mode Rules

1. **Zero Page: Use for variables accessed >10 times per frame
2. **Absolute: Use for constants, lookup tables, game state
3. **Indexed: Use for arrays, loops, sequential access
4. **Indirect: Use for function pointers, jump tables
5. **Stack Relative: Not available on 6502 (use absolute addressing)

### Failure Modes

* **Zero Page Overflow: Using too many zero page variables causes conflicts
* **Stack Overflow: Pushing more than 256 bytes wraps stack pointer
* **Uninitialized Pointer: Indirect addressing with uninitialized pointer crashes
* **PPU Register Timing: Accessing PPU registers at wrong time causes corruption
* **RAM Not Cleared: Uninitialized RAM causes unpredictable behavior
* **OAM Corruption: Writing to OAM during rendering causes sprite glitches
* **VRAM Write During Rendering: Causes visual corruption, incorrect tiles
* **Name Table Mirroring Confusion: Writing to wrong name table due to mirroring
* **Palette Address Confusion: Writing to mirrored palette addresses

## Memory Access Patterns and Best Practices

### Zero Page Allocation Strategy

**Priority order for zero page usage:**
1. **Hot variables** (accessed >10 times per frame)
2. **Pointers** (16-bit indirect addressing)
3. **Loop counters** (in hot loops)
4. **Temporary variables** (frequently used)

**Example allocation:**
```asm
; Zero page allocation
zp_frame_counter = $00      ; Hot: updated every frame
zp_scroll_x = $01           ; Hot: updated every frame
zp_scroll_y = $02           ; Hot: updated every frame
zp_ptr = $04                ; Pointer (2 bytes: $04, $05)
zp_temp = $06               ; Temporary variable
zp_loop_counter = $07       ; Loop counter
; ... more allocations ...
```

### Stack Usage Guidelines

**Stack depth limits:**
- Maximum safe depth: ~200 bytes (leave buffer)
- Typical usage: 10-50 bytes
- **Never exceed 256 bytes** (wraps silently)

**Stack frame example:**
```asm
my_function:
    PHA             ; +1 byte (save A)
    TXA
    PHA             ; +1 byte (save X)
    TYA
    PHA             ; +1 byte (save Y)
    ; Function uses 3 bytes of stack
    ; ... function code ...
    PLA             ; -1 byte (restore Y)
    TAY
    PLA             ; -1 byte (restore X)
    TAX
    PLA             ; -1 byte (restore A)
    RTS             ; Function complete
```

### OAM Buffer Management

**OAM buffer location**: $0200–$02FF (256 bytes, 64 sprites × 4 bytes)

**Best practice**: Update OAM buffer in main loop, transfer via DMA in NMI.

```asm
; Update OAM buffer (in main loop)
update_sprites:
    LDX #0
update_loop:
    LDA sprite_y,X
    STA $0200,X      ; Y position
    LDA sprite_tile,X
    STA $0201,X      ; Tile index
    LDA sprite_attr,X
    STA $0202,X      ; Attributes
    LDA sprite_x,X
    STA $0203,X      ; X position
    INX
    CPX sprite_count
    BNE update_loop
    RTS

; Transfer OAM via DMA (in NMI)
nmi:
    LDA $2
    LDA #0
    STA $3       ; OAM address = 0
    LDA #$02        ; High byte of OAM buffer
    STA $4       ; Start DMA (513 cycles)
    ; ... rest of NMI ...
```

## Explicit Non-Goals

This section does not cover:
* Detailed PPU memory layout (see 1.4)
* Cartridge mapper details (see 1.5)
* Timing-critical memory access (see 2.1, 2.3)
* Data-oriented design patterns (see 3.2)
* Memory map cheatsheet (see 4.3)

## Cross-References

- Related Fundamentals: 1.1 (System Overview), 1.2 (CPU), 1.4 (PPU), 1.5 (ROM)
- Related Advanced Fundamentals: 2.1 (CPU Timing), 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.2 (Data-Oriented Design)
- Related Cheatsheets: 4.3 (Memory Cheatsheets)
