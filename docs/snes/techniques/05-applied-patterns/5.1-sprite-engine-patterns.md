# 5.1 Sprite Engine Patterns

## Overview

SNES sprite engine patterns for managing OAM (Object Attribute Memory) and sprite rendering within hardware constraints.


## Fixed Sprite Slots

**Pattern**: Pre-allocate sprite slots for known entities (player, enemies, projectiles). Each entity type has a fixed range of OAM entries.

**Advantages**:
- Predictable OAM layout
- Easy to update specific entity types
- No dynamic allocation overhead

**Disadvantages**:
- Wastes OAM slots if entities are inactive
- Inflexible (can't exceed slot count)

**Implementation**:
```asm
; Fixed sprite slot allocation
SPRITE_PLAYER = 0        ; Slot 0: Player (1 sprite)
SPRITE_ENEMY_START = 1   ; Slots 1-10: Enemies (10 sprites)
SPRITE_PROJECTILE_START = 11  ; Slots 11-20: Projectiles (10 sprites)
SPRITE_UI_START = 21     ; Slots 21-30: UI elements (10 sprites)
SPRITE_COUNT = 128       ; SNES has 128 sprites

; OAM mirror location (WRAM)
OAM_MIRROR = $7E0400     ; 512 bytes sprite data
OAM_HI = $7E0600         ; 32 bytes size/priority table

; Update player sprite
update_player_sprite:
    ldx #SPRITE_PLAYER * 4
    lda player_y
    sta OAM_MIRROR,x     ; Y position
    inx
    lda #$00
    sta OAM_MIRROR,x     ; Tile index
    inx
    lda #%00000000
    sta OAM_MIRROR,x     ; Attributes
    inx
    lda player_x
    sta OAM_MIRROR,x     ; X position
    rts

; Update enemy sprites
update_enemy_sprites:
    ldx #0               ; Enemy index
    ldy #SPRITE_ENEMY_START * 4  ; OAM offset
enemy_loop:
    lda enemy_active,x
    beq enemy_off_screen
    
    ; Enemy is active, update sprite
    lda enemy_y,x
    sta OAM_MIRROR,y
    iny
    lda enemy_tile,x
    sta OAM_MIRROR,y
    iny
    lda enemy_attr,x
    sta OAM_MIRROR,y
    iny
    lda enemy_x,x
    sta OAM_MIRROR,y
    iny
    
    cpy #(SPRITE_ENEMY_START + 10) * 4
    beq enemy_done
    
enemy_off_screen:
    ; Move sprite off-screen (Y = 240)
    lda #240
    sta OAM_MIRROR,y
    iny
    iny
    iny
    iny
    
    cpy #(SPRITE_ENEMY_START + 10) * 4
    bne enemy_loop
    
enemy_done:
    rts
```

## Dynamic Sprite Allocation

**Pattern**: Allocate sprite slots on-demand from a free list. Sprites are allocated when entities spawn and freed when entities despawn.

**Advantages**:
- Efficient OAM usage (only active sprites use slots)
- Flexible (can allocate any number up to 128)
- Better for variable entity counts

**Disadvantages**:
- More complex (requires free list management)
- Fragmentation possible (gaps in OAM)
- Allocation overhead

**Implementation**:
```asm
; Sprite free list (bitmap: 1 = free, 0 = used)
sprite_free_list = $7E0700  ; 16 bytes (128 bits for 128 sprites)

; Initialize free list (all sprites free)
init_sprite_free_list:
    lda #$FF
    ldx #16              ; 16 bytes for 128 sprites
init_loop:
    sta sprite_free_list-1,x
    dex
    bne init_loop
    rts

; Allocate a sprite slot (returns slot index in A, or $FF if none available)
allocate_sprite:
    LDX #0          ; Byte index
    LDY #0          ; Bit index
alloc_loop:
    LDA sprite_free_list,X
    BEQ next_byte   ; No free bits in this byte
    
    ; Find first set bit
    LDY #0
find_bit:
    LSR A
    BCS bit_found
    INY
    CPY #8
    BNE find_bit
    
next_byte:
    inx
    cpx #16             ; 16 bytes for 128 sprites
    bne alloc_loop
    
    ; No free sprites
    LDA #$FF
    RTS
    
bit_found:
    ; Calculate slot index: X * 8 + Y
    TXA
    ASL A
    ASL A
    ASL A
    CLC
    ADC bit_index_table,Y
    PHA             ; Save slot index
    
    ; Mark sprite as used
    LDA sprite_free_list,X
    AND bit_clear_table,Y
    STA sprite_free_list,X
    
    PLA             ; Restore slot index
    RTS

; Free a sprite slot (A = slot index)
free_sprite:
    PHA
    ; Calculate byte and bit: slot / 8, slot % 8
    LSR A
    LSR A
    LSR A
    TAX             ; Byte index
    PLA
    AND #$07
    TAY             ; Bit index
    
    ; Mark sprite as free
    LDA sprite_free_list,X
    ORA bit_set_table,Y
    STA sprite_free_list,X
    
    RTS

; Bit manipulation tables
bit_index_table:
    .byte 0, 1, 2, 3, 4, 5, 6, 7
bit_clear_table:
    .byte %11111110, %11111101, %11111011, %11110111
    .byte %11101111, %11011111, %10111111, %01111111
bit_set_table:
    .byte %00000001, %00000010, %00000100, %00001000
    .byte %00010000, %00100000, %01000000, %10000000
```

## Sprite Flicker Prevention

**Pattern**: Rotate sprite priorities or limit sprites per scanline to prevent flicker when >32 sprites overlap (SNES limit is 32 sprites per scanline).

**Common Techniques**:
1. **Sprite priority rotation**: Rotate which sprites are visible each frame
2. **Distance-based culling**: Hide distant sprites when too many are on-screen
3. **Static allocation**: Reserve slots for important sprites (player, UI)

**Implementation** (Priority Rotation):
```asm
; Rotate sprite visibility each frame to prevent flicker
sprite_rotation = $00  ; Direct page: rotation offset

update_sprite_rotation:
    inc sprite_rotation
    lda sprite_rotation
    and #$1F        ; Rotate 0-31 (SNES has 32 sprites per scanline limit)
    sta sprite_rotation
    rts

; Update sprites with rotation
update_sprites_with_rotation:
    ldx #0           ; Entity index
    ldy #0           ; OAM offset
    lda sprite_rotation
    sta temp_rotation
    
sprite_loop:
    ; Check if sprite should be visible this frame
    lda temp_rotation
    cmp entity_index,x
    bcc sprite_hide  ; Rotation < index: hide
    
    ; Sprite is visible, update OAM mirror
    lda entity_y,x
    sta OAM_MIRROR,y
    iny
    lda entity_tile,x
    sta OAM_MIRROR,y
    iny
    lda entity_attr,x
    sta OAM_MIRROR,y
    iny
    lda entity_x,x
    sta OAM_MIRROR,y
    iny
    
    bra sprite_next
    
sprite_hide:
    ; Move sprite off-screen (Y = 240)
    lda #240
    sta OAM_MIRROR,y
    iny
    iny
    iny
    iny
    
sprite_next:
    inx
    cpx #entity_count
    bne sprite_loop
    
    rts
```

## Cross-References

- [OAM System](../../hardware/ppu/oam-system.md) - SNES sprite hardware
- [OAM Mirror](../../programming/rendering/oam-mirror.md) - WRAM sprite buffer
- [DMA OAM Updates](../../programming/rendering/dma-oam-updates.md) - DMA channel 0 for OAM
- [SNES Documentation Index](../../README.md) - Complete SNES documentation
