# 5.3 Collision Systems

## Overview

SNES collision detection patterns for tile-based and entity-based collision systems.


## Tile-Based Collision

**Pattern**: Check collision by reading tile data from VRAM or WRAM buffer. Entities collide with solid tiles (non-zero tile indices or specific collision flags).

**Advantages**:
- Simple and fast
- Works well with tile-based levels
- Deterministic (same tile = same collision)

**Disadvantages**:
- Only works with tile-aligned entities
- Requires tile-to-pixel coordinate conversion
- VRAM access requires VBlank window or WRAM buffer

**Implementation**:
```asm
; Tile-based collision check
; Input: X = entity X (pixels), Y = entity Y (pixels)
; Output: A = tile index (0 = empty, non-zero = solid)
check_tile_collision:
    ; Convert pixel X to tile X
    TXA
    LSR A
    LSR A
    LSR A             ; Divide by 8
    STA tile_x
    
    ; Convert pixel Y to tile Y
    TYA
    LSR A
    LSR A
    LSR A             ; Divide by 8
    STA tile_y
    
    ; Calculate name table address (SNES: 64x64 tiles)
    ; Address = base + (tile_y * 64) + tile_x
    lda tile_y
    asl a
    asl a
    asl a
    asl a
    asl a
    asl a             ; tile_y * 64 (SNES name table is 64x64)
    clc
    adc tile_x
    tax
    
    ; Read tile from WRAM buffer (VRAM access requires VBlank)
    ; SNES name table buffer in WRAM
    lda name_table_buffer,x  ; Read from RAM buffer
    
    RTS

; Check collision for entity movement
check_entity_collision:
    ; Get entity position
    LDA entity_x
    CLC
    ADC entity_vx     ; New X position
    TAX
    
    LDA entity_y
    CLC
    ADC entity_vy     ; New Y position
    TAY
    
    ; Check collision at new position
    JSR check_tile_collision
    BEQ no_collision  ; Tile = 0 (empty)
    
    ; Collision detected, don't move
    RTS
    
no_collision:
    ; No collision, update position
    STX entity_x
    STY entity_y
    RTS

; Name table buffer (WRAM copy of current name table)
name_table_buffer = $7E1000  ; 4096 bytes (64Ã—64 tiles, 2 bytes per tile)
```

## Bounding Box Collision

**Pattern: Check collision between entities using axis-aligned bounding boxes (AABB). Each entity has a rectangular collision box.

**Advantages:
* Works with pixel-precision entities
* Fast (simple rectangle overlap test)
* Works for entity-to-entity collision

**Disadvantages:
* Less precise than pixel-perfect collision
* Requires bounding box data per entity

**Implementation:
```asm
; Bounding box collision check
; Input: entity1 (x1, y1, w1, h1), entity2 (x2, y2, w2, h2)
; Output: A = 1 if collision, 0 if no collision
check_bounding_box:
    ; Calculate entity1 right edge
    LDA entity1_x
    CLC
    ADC entity1_w
    STA entity1_right
    
    ; Calculate entity1 bottom edge
    LDA entity1_y
    CLC
    ADC entity1_h
    STA entity1_bottom
    
    ; Calculate entity2 right edge
    LDA entity2_x
    CLC
    ADC entity2_w
    STA entity2_right
    
    ; Calculate entity2 bottom edge
    LDA entity2_y
    CLC
    ADC entity2_h
    STA entity2_bottom
    
    ; Check if entity1 left < entity2 right
    LDA entity1_x
    CMP entity2_right
    BCS no_collision
    
    ; Check if entity1 right > entity2 left
    LDA entity1_right
    CMP entity2_x
    BCC no_collision
    
    ; Check if entity1 top < entity2 bottom
    LDA entity1_y
    CMP entity2_bottom
    BCS no_collision
    
    ; Check if entity1 bottom > entity2 top
    LDA entity1_bottom
    CMP entity2_y
    BCC no_collision
    
    ; Collision detected
    LDA #1
    RTS
    
no_collision:
    LDA #0
    RTS

; Check collision between player and all enemies
check_player_enemy_collision:
    ; Get player bounding box
    LDA player_x
    STA entity1_x
    LDA player_y
    STA entity1_y
    LDA #8           ; Player width
    STA entity1_w
    LDA #8           ; Player height
    STA entity1_h
    
    ; Check against all enemies
    LDX #0
enemy_collision_loop:
    LDA enemy_active,X
    BEQ next_enemy   ; Enemy not active
    
    ; Get enemy bounding box
    LDA enemy_x,X
    STA entity2_x
    LDA enemy_y,X
    STA entity2_y
    LDA #8           ; Enemy width
    STA entity2_w
    LDA #8           ; Enemy height
    STA entity2_h
    
    ; Check collision
    JSR check_bounding_box
    BEQ next_enemy   ; No collision
    
    ; Collision detected
    JSR player_hit
    RTS
    
next_enemy:
    INX
    CPX #enemy_count
    BNE enemy_collision_loop
    
    ; No collisions
    RTS
```

## Hybrid Collision (Tile + Bounding Box)

**Pattern: Use tile-based collision for level geometry and bounding box collision for entity-to-entity interactions.

**Implementation:
```asm
; Hybrid collision system
check_hybrid_collision:
    ; First check tile collision (level geometry)
    LDA entity_x
    TAX
    LDA entity_y
    TAY
    JSR check_tile_collision
    BNE collision_detected  ; Hit solid tile
    
    ; Then check bounding box collision (entities)
    JSR check_player_enemy_collision
    BNE collision_detected  ; Hit enemy
    
    ; No collision
    LDA #0
    RTS
    
collision_detected:
    LDA #1
    RTS
```

## Cross-References

- [Background Layers](../../programming/rendering/background-layers.md) - SNES background setup
- [VRAM Management](../../programming/rendering/vram-management.md) - Tile data access
- [WRAM Organization](../../hardware/memory/wram-organization.md) - SNES work RAM
- [Scrolling Patterns](5.2-scrolling-patterns.md) - Related scrolling techniques
- [SNES Documentation Index](../../README.md) - Complete SNES documentation
