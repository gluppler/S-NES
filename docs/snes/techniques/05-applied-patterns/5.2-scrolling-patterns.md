# 5.2 Scrolling Patterns

## Overview

SNES scrolling patterns for managing background layers and camera systems using SNES PPU scroll registers and VRAM management.


## Horizontal Scrolling

**Pattern**: Update BG scroll registers (BG1HOFS/BG2HOFS) each frame based on camera position. Load new tiles via DMA when scrolling reveals new columns.

**Implementation**:
```asm
; Horizontal scroll variables (direct page)
scroll_x = $00        ; Direct page: scroll position (pixels)
camera_x = $02        ; Direct page: camera position (pixels)

; SNES PPU registers
BG1HOFS = $210D        ; BG1 horizontal scroll (write twice: low, high)
BG2HOFS = $210F        ; BG2 horizontal scroll

; Update horizontal scroll
update_horizontal_scroll:
    ; Increment camera
    inc camera_x
    
    ; Update scroll register (in NMI or during forced blank)
    lda camera_x
    sta scroll_x
    
    ; Check if we need to load new column
    lda camera_x
    and #$07          ; Fine scroll (0-7)
    bne no_new_column ; Not at tile boundary
    
    ; Load new column (right edge) via DMA
    jsr load_column_right
    
no_new_column:
    rts

; Load column at right edge of screen via DMA
load_column_right:
    ; Calculate which column to load
    lda camera_x
    lsr a
    lsr a
    lsr a             ; Divide by 8 (tile column)
    clc
    adc #32           ; Right edge column (32 tiles wide screen)
    and #$3F          ; Wrap at 64 tiles (SNES name table is 64x64)
    sta column_index
    
    ; Setup DMA for VRAM transfer
    ; (DMA setup code would go here - see VRAM Management docs)
    ; This is a simplified example
    
    rts

column_index: .byte 0
```

## Vertical Scrolling

**Pattern**: Update BG scroll registers (BG1VOFS/BG2VOFS) each frame based on camera position. Load new tiles via DMA when scrolling reveals new rows.

**Implementation**:
```asm
; Vertical scroll variables (direct page)
scroll_y = $04        ; Direct page: scroll position (pixels)
camera_y = $06        ; Direct page: camera position (pixels)

; SNES PPU registers
BG1VOFS = $210E        ; BG1 vertical scroll (write twice: low, high)
BG2VOFS = $2110        ; BG2 vertical scroll

; Update vertical scroll
update_vertical_scroll:
    ; Increment camera
    inc camera_y
    
    ; Update scroll register (in NMI or during forced blank)
    lda camera_y
    sta scroll_y
    
    ; Check if we need to load new row
    lda camera_y
    and #$07          ; Fine scroll (0-7)
    bne no_new_row    ; Not at tile boundary
    
    ; Load new row (bottom edge) via DMA
    jsr load_row_bottom
    
no_new_row:
    rts

; Load row at bottom edge of screen via DMA
load_row_bottom:
    ; Calculate which row to load
    lda camera_y
    lsr a
    lsr a
    lsr a             ; Divide by 8 (tile row)
    clc
    adc #32           ; Bottom edge row (32 tiles tall screen)
    and #$3F          ; Wrap at 64 tiles (SNES name table is 64x64)
    sta row_index
    
    ; Setup DMA for VRAM transfer
    ; (DMA setup code would go here - see VRAM Management docs)
    ; This is a simplified example
    
    rts

row_index: .byte 0
```

## Four-Way Scrolling Constraints

**Pattern**: Handle scrolling in both X and Y directions simultaneously. Must manage VRAM boundaries and coordinate tile loading via DMA.

**Constraints**:
- **Name table size**: 64×64 tiles per name table (SNES)
- **Scroll range**: 0–1023 pixels (10-bit scroll registers)
- **VRAM management**: Must use DMA for tile loading (manual writes too slow)
- **Tile loading**: Must load tiles in both X and Y directions during VBlank

**Implementation**:
```asm
; Four-way scroll variables (direct page)
scroll_x = $00
scroll_y = $04
bg_scroll_base = $08   ; Direct page: BG scroll base address

; SNES PPU registers
BG1HOFS = $210D        ; BG1 horizontal scroll
BG1VOFS = $210E        ; BG1 vertical scroll
BGSC = $2107           ; BG1 screen base and size

; Update four-way scroll
update_four_way_scroll:
    ; Update horizontal
    jsr update_horizontal_scroll
    
    ; Update vertical
    jsr update_vertical_scroll
    
    ; Update scroll registers (during forced blank or VBlank)
    ; Horizontal scroll
    lda scroll_x
    sta BG1HOFS        ; Low byte
    lda scroll_x+1
    sta BG1HOFS        ; High byte
    
    ; Vertical scroll
    lda scroll_y
    sta BG1VOFS        ; Low byte
    lda scroll_y+1
    sta BG1VOFS        ; High byte
    
    rts

; Load tiles for four-way scrolling (via DMA during VBlank)
load_scroll_tiles:
    ; Check if we need to load right column
    lda camera_x
    and #$07
    bne check_bottom_row
    jsr load_column_right
    
check_bottom_row:
    ; Check if we need to load bottom row
    lda camera_y
    and #$07
    bne load_done
    jsr load_row_bottom
    
load_done:
    rts
```

## Cross-References

- [Background Layers](../../programming/rendering/background-layers.md) - SNES background setup
- [VRAM Management](../../programming/rendering/vram-management.md) - DMA tile loading
- [General DMA](../../hardware/dma-hdma/general-dma.md) - DMA transfer modes
- [Background Modes](../../hardware/ppu/background-modes.md) - SNES background modes
- [SNES Documentation Index](../../README.md) - Complete SNES documentation
